package main

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/jmoiron/sqlx"
	"github.com/uptrace/bun"
	"github.com/uptrace/bun/dialect/pgdialect"
	"github.com/uptrace/bun/driver/pgdriver"
)

const serverTable = "servers"

const maxNameLength = 64
const maxDirectoryLength = 256
const maxJarFileLength = 64
const maxRunMemoryLength = 8
const maxStartMemoryLength = 8
const maxJavaArgsLength = 256

const maxNameLengthString = "64"
const maxDirectoryLengthString = "256"
const maxJarFileLengthString = "64"
const maxRunMemoryLengthString = "8"
const maxStartMemoryLengthString = "8"
const maxJavaArgsLengthString = "256"

const serverTableSchema = "id INT NOT NULL AUTO_INCREMENT, " +
	"name VARCHAR(" + maxNameLengthString + ") NOT NULL, " +
	"directory VARCHAR(" + maxDirectoryLengthString + ") NOT NULL, " +
	"jarfile VARCHAR(" + maxJarFileLengthString + ") NOT NULL, " +
	"runmemory VARCHAR(" + maxRunMemoryLengthString + ") NOT NULL, " +
	"startmemory VARCHAR(" + maxStartMemoryLengthString + ") NOT NULL, " +
	"javaargs VARCHAR(" + maxJavaArgsLengthString + "), " +
	"PRIMARY KEY (id)"

// id is omitted since it is generated by the database
const serverTableColumns = "name,directory,jarfile,runmemory,startmemory,javaargs"

var db *bun.DB

func databaseSetup() {
	db, err := sqlx.Open("postgres", config.Database.User+":"+config.Database.Password+
		"@("+config.Database.Host+":"+fmt.Sprint(config.Database.Port)+")"+"/")
	if err != nil {
		panic(err)
	}

	defer db.Close()

	err = db.Ping()
	if err != nil {
		panic(err)
	}

	_, err = db.Exec("CREATE DATABASE " + config.Database.Database)
	if err != nil {
		fmt.Println(err.Error())
	} else {
		fmt.Println("Successfully created database..")
	}

	_, err = db.Exec("USE " + config.Database.Database)
	if err != nil {
		fmt.Println(err)
	}

	_, err = db.Exec("CREATE TABLE " + serverTable + "(" + serverTableSchema + ")")
	if err != nil {
		fmt.Println(err)
	}
}

func connectDatabase() {
	sqldb := sql.OpenDB(pgdriver.NewConnector(pgdriver.WithDSN(buildConnectionString())))

	db = bun.NewDB(sqldb, pgdialect.New())

	// TODO: How to make this extend to life of daemon and still be closed properly
	// defer db.Close()

	db.SetConnMaxLifetime(time.Minute * 3)
	db.SetMaxOpenConns(10)
	db.SetMaxIdleConns(10)
}

func getSingleServerData(ctx context.Context, id int) (*databaseServer, error) {
	server := new(databaseServer)
	err := db.NewSelect().Model(server).Where("id = ?", id).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return server, nil
}

func requestServerToString(server requestServer) string {
	if len(server.JavaArgs) > 0 {
		return "\"" + server.Name + "\",\"" + server.Directory + "\",\"" + server.JarFile + "\",\"" + server.RunMemory + "\",\"" + server.StartMemory + "\",\"" + server.JavaArgs + "\""
	}

	return "\"" + server.Name + "\",\"" + server.Directory + "\",\"" + server.JarFile + "\",\"" + server.RunMemory + "\",\"" + server.StartMemory + "\",null"
}

func addServerToDatabase(ctx context.Context, server requestServer) (int64, error) {
	res, err := db.NewInsert().Model(convertrequestServerToDBServer(server)).Exec(ctx)
	if err != nil {
		return 0, err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return 0, err
	}
	return id, nil
}

func collectServerData(ctx context.Context) []responseServer {
	var servers []databaseServer
	err := db.NewSelect().Model(&servers).Scan(ctx)
	if err != nil {
		fmt.Println(err)
	}

	var serverList []responseServer
	for _, dbServer := range servers {
		server := responseServer{
			dbServer.ID,
			dbServer.Name,
			dbServer.Directory,
			dbServer.JarFile,
			dbServer.RunMemory,
			dbServer.StartMemory,
			dbServer.JavaArgs.String,
			getServerStatus(dbServer.ID),
		}
		serverList = append(serverList, server)
	}

	return serverList
}

// A duplicate server is defined by a server having either the same name or directory as another.
func checkForDuplicateServer(name, directory string) (bool, error) {
	result, err := db.Queryx("SELECT * FROM " + serverTable + " WHERE `name` = \"" + name + "\"")
	if err != nil {
		return true, err
	}

	defer result.Close()

	var temp databaseServer
	for result.Next() {
		if err := result.StructScan(&temp); err != nil {
			return true, err
		}
	}

	if len(temp.Name) > 0 {
		return true, nil
	}

	result, err = db.Queryx("SELECT * FROM " + serverTable + " WHERE `directory` = \"" + directory + "\"")
	if err != nil {
		return true, err
	}

	defer result.Close()

	for result.Next() {
		if err := result.StructScan(&temp); err != nil {
			return true, err
		}
	}

	if len(temp.Name) > 0 {
		return true, nil
	}

	return false, nil
}

func checkForDuplicateServerName(name string) (bool, error) {
	result, err := db.Queryx("SELECT * FROM " + serverTable + " WHERE `name` = \"" + name + "\"")
	if err != nil {
		return true, err
	}

	defer result.Close()

	var temp databaseServer
	for result.Next() {
		if err := result.StructScan(&temp); err != nil {
			return true, err
		}
	}

	if len(temp.Name) > 0 {
		return true, nil
	}

	return false, nil
}

func checkForDuplicateServerDir(directory string) (bool, error) {
	result, err := db.Queryx("SELECT * FROM " + serverTable + " WHERE `directory` = \"" + directory + "\"")
	if err != nil {
		return true, err
	}

	defer result.Close()

	var temp databaseServer
	for result.Next() {
		if err := result.StructScan(&temp); err != nil {
			return true, err
		}
	}

	if len(temp.Name) > 0 {
		return true, nil
	}

	return false, nil
}

func modifyServerEntry(server requestServer, serverID int) error {
	result, err := db.Queryx("UPDATE " + serverTable + " SET name = \"" + server.Name + "\", directory = \"" + server.Directory + "\", jarfile = \"" + server.JarFile + "\", runmemory = \"" + server.RunMemory + "\", startmemory = \"" + server.StartMemory + "\", javaargs = \"" + server.JavaArgs + "\" WHERE `id` = " + fmt.Sprintf("%d", serverID))
	if err != nil {
		return err
	}

	defer result.Close()

	return nil
}

func getServerStatus(serverID int) ServerStatus {
	server := runningServers.Find(serverID)
	if server != nil {
		return Running
	} else {
		return Stopped
	}
}

func convertrequestServerToDBServer(server requestServer) databaseServer {
	return databaseServer{
		0,
		server.Name,
		server.Directory,
		server.JarFile,
		server.RunMemory,
		server.StartMemory,
		sql.NullString{server.JavaArgs, true},
	}
}

func buildConnectionString() string {
	return "postgres://" + config.Database.User + ":" + config.Database.Password +
		"@(" + config.Database.Host + ":" + fmt.Sprint(config.Database.Port) + ")" +
		"/" + config.Database.Database
}
